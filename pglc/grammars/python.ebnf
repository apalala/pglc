@@grammar :: Python
@@whitespace :: /(?:(?!\n)\s)+/
@@left_recursion :: False
@@parseinfo :: True

single_input
    =
    newline | simple_stmt | compound_stmt newline
    ;


file_input
    =
    {newline | stmt}* endmarker
    ;


eval_input
    =
    testlist {newline}* endmarker
    ;


decorator
    =
    '@' dotted_name ['(' [arglist] ')'] newline
    ;


decorators
    =
    {decorator}+
    ;


decorated
    =
    decorators classdef | funcdef | async_funcdef
    ;


async_funcdef
    =
    async funcdef
    ;


funcdef
    =
    'def' name parameters ['->' test] ':' [type_comment] func_body_suite
    ;


parameters
    =
    '(' [typedargslist] ')'
    ;


typedargslist
    =
    | tfpdef ['=' test] {',' [type_comment] tfpdef ['=' test]}* | type_comment
    | [',' [type_comment] [| '*' [tfpdef] {',' [type_comment] tfpdef ['=' test]}* type_comment | [',' [type_comment] ['**' tfpdef [','] [type_comment]]]
    | '**' tfpdef [','] [type_comment]]]
    | '*' [tfpdef] {',' [type_comment] tfpdef ['=' test]}* type_comment | [',' [type_comment] ['**' tfpdef [','] [type_comment]]]
    | '**' tfpdef [','] [type_comment]
    ;


tfpdef
    =
    name [':' test]
    ;


varargslist
    =
    | vfpdef ['=' test] {',' vfpdef ['=' test]}* [',' [| '*' [vfpdef] {',' vfpdef ['=' test]}* [',' ['**' vfpdef [',']]]
    | '**' vfpdef [',']]]
    | '*' [vfpdef] {',' vfpdef ['=' test]}* [',' ['**' vfpdef [',']]]
    | '**' vfpdef [',']
    ;


vfpdef
    =
    name
    ;


stmt
    =
    simple_stmt | compound_stmt
    ;


simple_stmt
    =
    small_stmt {';' small_stmt}* [';'] newline
    ;


small_stmt
    =
    | expr_stmt
    | del_stmt
    | pass_stmt
    | flow_stmt
    | import_stmt
    | global_stmt
    | nonlocal_stmt
    | assert_stmt
    ;


expr_stmt
    =
    testlist_star_expr | annassign
    | augassign yield_expr | testlist
    | [{'=' yield_expr | testlist_star_expr}+ [type_comment]]
    ;


annassign
    =
    ':' test ['=' yield_expr | testlist]
    ;


testlist_star_expr
    =
    test | star_expr {',' test | star_expr}* [',']
    ;


augassign
    =
    | '+='
    | '-='
    | '*='
    | '@='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | '>>='
    | '**='
    | '//='
    ;


del_stmt
    =
    'del' exprlist
    ;


pass_stmt
    =
    'pass'
    ;


flow_stmt
    =
    break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
    ;


break_stmt
    =
    'break'
    ;


continue_stmt
    =
    'continue'
    ;


return_stmt
    =
    'return' [testlist_star_expr]
    ;


yield_stmt
    =
    yield_expr
    ;


raise_stmt
    =
    'raise' [test ['from' test]]
    ;


import_stmt
    =
    import_name | import_from
    ;


import_name
    =
    'import' dotted_as_names
    ;


import_from
    =
    'from' {'.' | '...'}* dotted_name | {'.' | '...'}+ 'import' '*' | '(' import_as_names ')' | import_as_names
    ;


import_as_name
    =
    name ['as' name]
    ;


dotted_as_name
    =
    dotted_name ['as' name]
    ;


import_as_names
    =
    import_as_name {',' import_as_name}* [',']
    ;


dotted_as_names
    =
    dotted_as_name {',' dotted_as_name}*
    ;


dotted_name
    =
    name {'.' name}*
    ;


global_stmt
    =
    'global' name {',' name}*
    ;


nonlocal_stmt
    =
    'nonlocal' name {',' name}*
    ;


assert_stmt
    =
    'assert' test [',' test]
    ;


compound_stmt
    =
    | if_stmt
    | while_stmt
    | for_stmt
    | try_stmt
    | with_stmt
    | funcdef
    | classdef
    | decorated
    | async_stmt
    ;


async_stmt
    =
    async funcdef | with_stmt | for_stmt
    ;


if_stmt
    =
    'if' namedexpr_test ':' suite {'elif' namedexpr_test ':' suite}* ['else' ':' suite]
    ;


while_stmt
    =
    'while' namedexpr_test ':' suite ['else' ':' suite]
    ;


for_stmt
    =
    'for' exprlist 'in' testlist ':' [type_comment] suite ['else' ':' suite]
    ;


try_stmt
    =
    'try' ':' suite | {except_clause ':' suite}+ ['else' ':' suite] ['finally' ':' suite]
    | 'finally' ':' suite
    ;


with_stmt
    =
    'with' with_item {',' with_item}* ':' [type_comment] suite
    ;


with_item
    =
    test ['as' expr]
    ;


except_clause
    =
    'except' [test ['as' name]]
    ;


suite
    =
    simple_stmt | newline indent {stmt}+ dedent
    ;


namedexpr_test
    =
    test [':=' test]
    ;


test
    =
    or_test ['if' or_test 'else' test] | lambdef
    ;


test_nocond
    =
    or_test | lambdef_nocond
    ;


lambdef
    =
    'lambda' [varargslist] ':' test
    ;


lambdef_nocond
    =
    'lambda' [varargslist] ':' test_nocond
    ;


or_test
    =
    and_test {'or' and_test}*
    ;


and_test
    =
    not_test {'and' not_test}*
    ;


not_test
    =
    'not' not_test | comparison
    ;


comparison
    =
    expr {comp_op expr}*
    ;


comp_op
    =
    | '<'
    | '>'
    | '=='
    | '>='
    | '<='
    | '<>'
    | '!='
    | 'in'
    | 'not' 'in'
    | 'is'
    | 'is' 'not'
    ;


star_expr
    =
    '*' expr
    ;


expr
    =
    xor_expr {'|' xor_expr}*
    ;


xor_expr
    =
    and_expr {'^' and_expr}*
    ;


and_expr
    =
    shift_expr {'&' shift_expr}*
    ;


shift_expr
    =
    arith_expr {'<<' | '>>' arith_expr}*
    ;


arith_expr
    =
    term {'+' | '-' term}*
    ;


term
    =
    factor {'*' | '@' | '/' | '%' | '//' factor}*
    ;


factor
    =
    '+' | '-' | '~' factor | power
    ;


power
    =
    atom_expr ['**' factor]
    ;


atom_expr
    =
    [await] atom {trailer}*
    ;


atom
    =
    | '(' [yield_expr | testlist_comp] ')'
    | '[' [testlist_comp] ']'
    | '{' [dictorsetmaker] '}'
    | name
    | number
    | {string}+
    | '...'
    | 'None'
    | 'True'
    | 'False'
    ;


testlist_comp
    =
    namedexpr_test | star_expr comp_for | {',' namedexpr_test | star_expr}* [',']
    ;


trailer
    =
    '(' [arglist] ')' | '[' subscriptlist ']' | '.' name
    ;


subscriptlist
    =
    subscript {',' subscript}* [',']
    ;


subscript
    =
    test | [test] ':' [test] [sliceop]
    ;


sliceop
    =
    ':' [test]
    ;


exprlist
    =
    expr | star_expr {',' expr | star_expr}* [',']
    ;


testlist
    =
    test {',' test}* [',']
    ;


dictorsetmaker
    =
    | test ':' test | '**' expr comp_for | {',' test ':' test | '**' expr}* [',']
    | test | star_expr comp_for | {',' test | star_expr}* [',']
    ;


classdef
    =
    'class' name ['(' [arglist] ')'] ':' suite
    ;


arglist
    =
    argument {',' argument}* [',']
    ;


argument
    =
    test [comp_for] | test ':=' test | test '=' test | '**' test | '*' test
    ;


comp_iter
    =
    comp_for | comp_if
    ;


sync_comp_for
    =
    'for' exprlist 'in' or_test [comp_iter]
    ;


comp_for
    =
    [async] sync_comp_for
    ;


comp_if
    =
    'if' test_nocond [comp_iter]
    ;


encoding_decl
    =
    name
    ;


yield_expr
    =
    'yield' [yield_arg]
    ;


yield_arg
    =
    'from' test | testlist_star_expr
    ;


func_body_suite
    =
    simple_stmt | newline [type_comment newline] indent {stmt}+ dedent
    ;


func_type_input
    =
    func_type {newline}* endmarker
    ;


func_type
    =
    '(' [typelist] ')' '->' test
    ;


typelist
    =
    | test {',' test}* [',' ['*' [test] {',' test}* [',' '**' test] | '**' test]]
    | '*' [test] {',' test}* [',' '**' test]
    | '**' test
    ;


