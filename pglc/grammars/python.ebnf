@@grammar :: Python
@@left_recursion :: False
@@parseinfo :: True
@@whitespace :: /(?:(?!\r?\n|\r)(?:\s|\\\n))+/
@@eol_comments :: /(?ms)(?:(?!\n)\s)*#[^\n]*?(?=\n|$)/
@@nameguard :: True
@@namechars :: '_'

@@keyword :: False      await      else       import     pass
@@keyword :: None       break      except     in         raise
@@keyword :: True       class      finally    is         return
@@keyword :: and        continue   for        lambda     try
@@keyword :: as         def        from       nonlocal   while
@@keyword :: assert     del        global     not        with
@@keyword :: async      elif       if         or         yield


start
    =
    (
      file_input
    | eval_input
    | single_input
    ) $
    ;


single_input
    =
    compound_stmt NEWLINE  | simple_stmt | NEWLINE
    ;


file_input
    =
    encoding:[ENCODING]
    statements:{_ stmt _}* _ ENDMARKER
    ;


eval_input
    =
    @:testlist _ ENDMARKER
    ;


decorator
    =
    '@' name:dotted_name ['(' ~ arglist:[arglist] _ ')'] NEWLINE
    ;


decorators
    =
    {decorator}+
    ;


decorated
    =
    decorators:decorators def:(classdef | funcdef | async_funcdef)
    ;


async_funcdef
    =
    'async' def:funcdef
    ;


funcdef
    =
    'def' ~ name:name parameters:parameters
    ['->' type:test] ':' ~ [type:TYPE_COMMENT ~] body:func_body_suite
    ;


parameters
    =
    '(' _ arglist:[typedargslist] _ ')'
    ;


# NOTE:
# This version is from the reference documentation, adding TYPE_COMMENT
#       https://docs.python.org/3.8/reference/compound_stmts.html#function-definitions
typedargslist = parameter_list ;


parameter_list
    =
      defparameter {',' [typec] defparameter}* ',' [typec] '/' ~ [',' [parameter_list_no_posonly]]
    | parameter_list_no_posonly
    ;


parameter_list_no_posonly
    =
      defparameter {',' [typec] defparameter }* [',' [typec] [parameter_list_starargs]]
    | parameter_list_starargs
    ;

parameter_list_starargs
    =
      '*' [parameter] {',' [typec] defparameter}* [',' [typec] ['**' parameter [',' ~ [typec]]]]
    | '**' parameter [',' ~ [typec]]
    ;

defparameter            = parameter  ['=' ~ expression] ;
parameter               = identifier [':' ~ expression] ;
identifier              = name;
expression              = test;
typec                   = TYPE_COMMENT ~ ;


# FIXME: this was an attempt to clean up the rules from Grammar/Grammar
__second_version_typedargslist
    =
    [posargs:typedposonlyargs ',']
    (
        |
            [args:typedargs] (vararg:typedvararg|args+:typedarg)
            [',' _ [args:typedargs] args+:(typedkwvararg|typedarg)]
        | [args:typedargs] (kwarg:typedkwvararg|args+:typedarg)
        | args+:typedkwvararg
        | varag:typedvararg [[','] TYPE_COMMENT]
        | args:typedargs
    )
    |
        posargs:typedposonlyargs [[','] TYPE_COMMENT]
    ;


typedarg
    =
    name:tfpdef ['='  _ value:test] &[[','] type:TYPE_COMMENT]
    ;


typedargs
    =
    {@+:typedarg ',' [TYPE_COMMENT] _ }+
    ;

typedposonlyargs
    =
    [@+:typedargs] '/'
    ;

typedvararg
    =
    '*' !'*' ~ [def:tfpdef ~ &[[','] type:TYPE_COMMENT] ]
    ;


typedkwvararg
    =
    '**' ~ def:tfpdef ~ [[','] type:TYPE_COMMENT]
    ;


# FIXME: these are the rules bootstrapped from Grammar/Grammar
__original_typedargslist
    =
        '**' ~ tfpdef [','] [TYPE_COMMENT]
    |
        '*' !'*' ~ [tfpdef] {',' [TYPE_COMMENT] _ tfpdef ~ ['=' ~ test]}*
        (
                TYPE_COMMENT
            |
                [',' [TYPE_COMMENT] [ _ '**' tfpdef [','] [TYPE_COMMENT]]]
        )
    |
        tfpdef ['=' test] {',' _ [TYPE_COMMENT] tfpdef ~['=' test]}*
        (
                TYPE_COMMENT
            |
                [
                    ',' [TYPE_COMMENT]
                    [
                        |  '**' ~ tfpdef [','] [TYPE_COMMENT]
                        |  '*' !'*' ~ [tfpdef] {',' _ [TYPE_COMMENT] tfpdef ~ ['=' ~ test]}*
                            (
                                    TYPE_COMMENT
                                |
                                    [',' [TYPE_COMMENT] [_ '**' tfpdef [','] [TYPE_COMMENT]]]
                            )
                    ]
                ]
        )
    ;


tfpdef
    =
    name:name [ ':' ~ type:test]
    ;


varargslist = argument_list [',' ~];

argument_list
    =
      positional_arguments [',' starred_and_keywords] [',' keywords_arguments]
    | starred_and_keywords [',' keywords_arguments]
    | keywords_arguments
    ;

positional_arguments
    =
    ['*'] expression {',' ['*'] expression}*
    ;

starred_and_keywords
    =
    ('*' expression | keyword_item) {',' '*' expression | ',' keyword_item}*
    ;

keywords_arguments
    =
    (keyword_item | '**' ~ expression) {',' keyword_item | ',' '**' ~ expression}*
    ;


keyword_item
    =
    identifier '=' ~ expression
    ;


# FIXME dropped rewrite
__varargslist
    =
    [posargs:posonlyargs ',']
    (
        |
            [args:args] (vararg:vararg|args+:arg)
            [',' _ [args:args] (kwarg:kwvararg|args+:arg)]
        | [args:args] (kwarg:kwvararg|args+:arg)
        | kwarg:kwvararg
        | vararg:vararg [',']
        | args:args
    )
    |
        posargs:posonlyargs [',']
    ;


vfpdef
    =
    name
    ;


arg
    =
    def:vfpdef ['=' _ value:test]
    ;


args
    =
    {@+:arg ',' _ }+
    ;


posonlyargs
    =
    [@+:args ','] '/'
    ;


vararg
    =
    '*' !'*' ~ @:test
    ;


kwvararg
    =
    '**' ~ @:test
    ;



_original_varargslist
    =
    |   vfpdef ['=' _ test]
        {',' vfpdef ['=' _ test]}*
        [
             ','
            [
                  '*' [vfpdef] {',' vfpdef ['=' _ test]}* [',' ['**' vfpdef [',']]]
                | '**' vfpdef [',']
            ]
        ]
    | '*' [vfpdef] {',' vfpdef ['=' _ test]}* [',' ['**' vfpdef [',']]]
    | '**' vfpdef [',']
    ;


stmt
    =
    compound_stmt | simple_stmt
    ;


simple_stmt
    =
    @+:small_stmt {';' _ @+:small_stmt ~}* [';' ~] NEWLINE
    ;


small_stmt
    =
    | expr_stmt
    | flow_stmt
    | del_stmt
    | pass_stmt
    | global_stmt
    | nonlocal_stmt
    | assert_stmt
    | import_stmt
    ;


string_stmt
    =
    string
    ;


expr_stmt
    =
    exp+:testlist_star_expr
    (
          op:annassign
        | op:augassign value:(yield_expr | testlist)
        # FIXME: need to figure this out
        | {'=' exp+:(yield_expr | testlist_star_expr)}+ [TYPE_COMMENT]
        | ()
    )
    ;


annassign
    =
    ':' ~ type:test ['=' ~ value:(yield_expr | testlist)]
    ;


testlist_star_expr
    =
    (test | star_expr) {',' _ (test | star_expr)}* [',' ~]
    ;


augassign
    =
    | '+='
    | '-='
    | '*='
    | '@='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | '>>='
    | '**='
    | '//='
    ;


del_stmt
    =
    'del' ~ @:exprlist
    ;


pass_stmt
    =
    'pass' ~
    ;


flow_stmt
    =
    break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
    ;


break_stmt
    =
    'break' ~
    ;


continue_stmt
    =
    'continue' ~
    ;


return_stmt
    =
    'return' ~ @:[testlist_star_expr]
    ;


yield_stmt
    =
    yield_expr ~
    ;


raise_stmt
    =
    'raise' ~ [target:test ['from' ~ from:test]]
    ;


import_stmt
    =
    import_name | import_from
    ;


import_name
    =
    'import' ~ @:dotted_as_names
    ;


import_from
    =
    'from' ~ (up:{'.' | '...'}* parent:dotted_name | up:{'.' | '...'}+)
    'import' ~
    (
          '*' ~
        | '(' _ ~ modules:import_as_names _ ')'
        | modules:import_as_names
    )
    ;


import_as_name
    =
    name:name ['as' ~ as:name]
    ;


dotted_as_name
    =
    name:dotted_name ['as' ~ as:name]
    ;


import_as_names
    =
    @+:import_as_name {',' _ @+:import_as_name}* [',' ~]
    ;


dotted_as_names
    =
    @+:dotted_as_name {',' @+:dotted_as_name}*
    ;


dotted_name
    =
    @+:name {_ '.' _ ~ @+:name}*
    ;


global_stmt
    =
    'global' ~ @+:name {',' @+:name}*
    ;


nonlocal_stmt
    =
    'nonlocal' ~ @+:name {',' ~ @+:name}*
    ;


assert_stmt
    =
    'assert' @+:test [',' @+:test]
    ;


compound_stmt
    =
    | if_stmt
    | for_stmt
    | while_stmt
    | try_stmt
    | with_stmt
    | funcdef
    | classdef
    | decorated
    | async_stmt
    ;


async_stmt
    =
    'async' ~ @:(funcdef | with_stmt | for_stmt)
    ;


if_stmt
    =
    'if' ~ condition:namedexpr_test ':' ~ body:suite
    {EQDENT 'elif' ~ elif+:namedexpr_test ':' ~ suite}*
    [EQDENT 'else' ~ ':' ~ else:suite]
    ;


while_stmt
    =
    'while' ~ condition:namedexpr_test ':' ~ suite
    [EQDENT 'else' ~ ':' ~ else:suite]
    ;


for_stmt
    =
    'for' ~ exp:exprlist 'in' ~ target:testlist ':' ~ [TYPE_COMMENT ~] body:suite
    [EQDENT 'else' ~ ':' ~ else:suite]
    ;


try_stmt
    =
    'try' ~ ':' ~ body:suite
    (
            {EQDENT except_clause ~ ':' ~ except:suite}+ ~
            [EQDENT 'else' ~ ':' ~ else:suite]
            [EQDENT 'finally' ~ ':' ~ finally:suite]
        |
            EQDENT 'finally' ~ ':' ~ finally:suite
    )
    ;


with_stmt
    =
    'with' ~ item+:with_item {',' item+:with_item}* ':' ~
    type:[TYPE_COMMENT] body:suite
    ;


with_item
    =
    value:test ['as' as:expr]
    ;


except_clause
    =
    'except' ~ [value:test ['as' as:name]]
    ;


suite
    =
      NEWLINE  ~ INDENT stmpt+:stmt ~ {EQDENT stmt+:stmt ~}* ~ DEDENT
    | stmpt+:simple_stmt
    ;


namedexpr_test
    =
    name:test [':=' ~ value:test]
    ;


test
    =
    lambdef | ordef
    ;

ordef
    =
    value:or_test [_ 'if' _ condition:or_test _ 'else' ~  _ ~ else:test ]
    ;


test_nocond
    =
    or_test | lambdef_nocond
    ;


lambdef
    =
    'lambda' ~ [args:varargslist] ':' ~ _ exp:test
    ;


lambdef_nocond
    =
    'lambda' [args:varargslist] ':' ~ exp:test_nocond
    ;


or_test
    =
    exp:and_test {_ 'or' ~ _ exp:and_test}*
    ;


and_test
    =
    exp:not_test {_ 'and' ~ _ exp:not_test}*
    ;


not_test
    =
    'not' exp:not_test | @:comparison
    ;


comparison
    =
    #FIXME: this needs work
    exp:expr  comparison:{_ comp_op _ ~ expr}*
    ;


comp_op
    =
    | '=='
    | '>='
    | '<='
    | '<>'
    | '<' !'<'
    | '>' !'>'
    | '!='
    | 'not' 'in'
    | 'in'
    | 'is' 'not'
    | 'is'
    ;


star_expr
    =
    '*' ~ @:expr
    ;


# FIXME: use left/right recursion to fix associativity syntactically
expr
    =
    xor_expr {'|' !'=' ~ _ xor_expr}*
    ;


xor_expr
    =
    and_expr {'^' !'=' ~ _ and_expr}*
    ;


and_expr
    =
    shift_expr {'&' !'=' ~ _ shift_expr}*
    ;


shift_expr
    =
    arith_expr {('<<' | '>>') !'=' ~ _ arith_expr}*
    ;


arith_expr
    =
    term {_ ('+' | '-') !'=' ~ _ term}*
    ;


term
    =
    factor {_ ('*' !'*' | '@' | '%' | '//' | '/') !'=' ~ _ factor}*
    ;


factor
    =
    ('+' | '-' | '~') ~ factor | power
    ;


power
    =
    atom_expr ['**' !'=' ~ factor]
    ;


atom_expr
    =
    ['await' ~] atom {trailer}*
    ;


atom
    =
    (
        |
            (
                | '(' _ [yield_expr | testlist_comp] _ ')'
                | '[' _ [testlist_comp] _ ']'
                | '{' _ [dictorsetmaker] _ '}'
                | string
                | number
                | '...'
                | 'None'
                | 'True'
                | 'False'
            ) ~
        | name
    ) ~
    ;


testlist_comp
    =
    (namedexpr_test | star_expr) _
    (
          comp_for
        | {',' _ (namedexpr_test | star_expr) ~ _}* [',']
    )
    ;


trailer
    =
    '(' _ ~ [arglist] _ ')' | '[' _ ~ subscriptlist _ ']' | _ '.' ~ _ name
    ;


subscriptlist
    =
    subscript {','  _ subscript _ }* [',']
    ;


subscript
    =
    [test] ':' ~ _ ~ [test] [sliceop] | test
    ;


sliceop
    =
    ':' ~ _ ~ [test]
    ;


exprlist
    =
    @+:(expr | star_expr) {',' @+:(expr | star_expr)}* [',']
    ;


testlist
    =
    test {',' test}* [',']
    ;


dictorsetmaker
    =
        (test ':' ~ _ test | '**' expr) _
        (comp_for | {',' _ (test ':' ~ _ test | '**' expr) ~ }* [','])
    |
        (test | star_expr) _
        (comp_for | {','  _ (test | star_expr) ~ }* [','])
    ;


classdef
    =
    'class' ~ name ['(' ~ [arglist] _ ')'] ':' ~ suite
    ;


arglist
    =
    _ argument {',' _ argument}* [',' ~ _]
    ;


argument
    =
    | test ':=' _ test
    | test '=' _ test
    | '**' test
    | '*' test
    | test [ comp_for]
    ;


comp_iter
    =
    _ (comp_for | comp_if)
    ;


sync_comp_for
    =
    'for' ~ exprlist _ 'in' ~ _ or_test _ [comp_iter]
    ;


comp_for
    =
    _ ['async' ~] sync_comp_for
    ;


comp_if
    =
    'if' ~ test_nocond [comp_iter]
    ;


encoding_decl
    =
    name
    ;


yield_expr
    =
    'yield' ~ [yield_arg]
    ;


yield_arg
    =
    'from' ~ test | testlist_star_expr
    ;


func_body_suite
    =
      NEWLINE  ~ [TYPE_COMMENT ~ NEWLINE ] ~ INDENT stmt ~ {EQDENT stmt ~}* DEDENT
    | simple_stmt
    ;


func_type_input
    =
    func_type [NEWLINE] ENDMARKER
    ;


func_type
    =
    '(' [typelist] ')' '->' ~ test
    ;


typelist
    =
        | '**' ~ test
        | test {',' ~ test}* ['**' ~ test]
        | '*' [test] {',' ~ test}* [',' '**' ~ test]
        | ',' ['*' ~ [test] {',' test}* [',' '**' ~ test]]
    ;


@name
name
    =
    /[_]*\w[\w_]*/
    ;


number
    =
    floatnumber
    | integer
    ;


integer
    =
    bininteger | octinteger | hexinteger | decinteger
    ;


decinteger
    =
    #  nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
    /[1-9]([_]?\d)*|0+([_]?0)*/
    ;


bininteger
    =
    # "0" ("b" | "B") (["_"] bindigit)+
    /0[bB]([_]?[01])+/
    ;


octinteger
    =
    # "0" ("o" | "O") (["_"] octdigit)+
    /0[oO]([_]?[0-7])+/
    ;


hexinteger
    =
    # "0" ("x" | "X") (["_"] hexdigit)+
    /0[xX]([_]?[\da-fA-F])+/
    ;


floatnumber
    =
    # floatnumber   ::=  pointfloat | exponentfloat
    # pointfloat    ::=  [digitpart] fraction | digitpart "."
    # exponentfloat ::=  (digitpart | pointfloat) exponent
    # digitpart     ::=  digit (["_"] digit)*
    # fraction      ::=  "." digitpart
    # exponent      ::=  ("e" | "E") ["+" | "-"] digitpart
    | /[.]\d([_]?\d)*([eE][-+]?\d([_]?\d)*)?/
    | /\d([_]?\d)*[.](\d([_]?\d)*)?([eE][-+]?\d([_]?\d)*)?/
    | /\d([_]?\d)*[eE][-+]?\d([_]?\d)*/
    ;


string
    =
    (f_string|n_string) ~ {_ (f_string|n_string)}*
    ;

n_string
    =
    STRING
    ;

STRING
    =
    &/(r[bu]?|[bu]r?)?('''|""")/ ~
    /(?xs)
    (r[bu]?|[bu]r?)?'''(\\\\|\\'||\\"|\\.|.)*?'''
    |
    (r[bu]?|[bu]r?)?"""(\\\\|\\'||\\"|\\.|.)*?"""
    /
    |
    &/(r[bu]?|[bu]r?)?["']/ ~
    /(?xs)
    (r[bu]?|[bu]r?)?'(\\\\|\\'||\\"|\\.|.)*?'
    |
    (r[bu]?|[bu]r?)?"(\\\\|\\'||\\"|\\.|.)*?"
    /
    ;


f_string
    =
    FSTRING
    ;

FSTRING
    =
    &/f(r[bu]?|[bu]r?)?('''|""")/ ~
    /(?xs)
    f(r[bu]?|[bu]r?)?'''(.|\\|\'|\.)*?'''
    |
    f(r[bu]?|[bu]r?)?"""(.|\\|\"|\.)*?"""
    /
    |
    &/f(r[bu]?|[bu]r?)?["']/ ~
    /(?xs)
    f(r[bu]?|[bu]r?)?'(.|\\|\'|\.)*?'
    |
    f(r[bu]?|[bu]r?)?"(.|\\|\"|\.)*?"
    /
    ;


NEWLINE = () ; # /(?:(?:\s|\\\n)*(?:#[^\n]*?)?\n)+/ ~ | /\s*$/ $;

_ = () ; # /(?:(?:\s|\\\n)*(?:#[^\n]*?)?\n)*/ ;

@nomemo
INDENT = () ; # /(?:\s*(?:#[^\n]*?)?\n)*/  @:/^\s+/ ;

@nomemo
DEDENT = () ; # /(?:\s*(?:#[^\n]*?)?\n)*/  @:&/^\s*/ ;

@nomemo
EQDENT = () ; # /(?:\s*(?:#.[^\n]*?)?\n)*/ @:/^\s*/ ;

ENDMARKER = $ ;

TYPE_COMMENT
    =
    /\s*#\s*type:.*$/
    ;


ENCODING
    =
    /[-_\w]+/
    ;



