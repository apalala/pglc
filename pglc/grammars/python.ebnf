@@grammar :: Python
@@left_recursion :: False
@@parseinfo :: True
@@whitespace :: /(?:(?!\r?\n|\r)(?:\s|\\\n))+/
@@eol_comments :: /(?ms)(?:(?!\n)\s)*#[^\n]*?(?=\n|$)/
@@nameguard :: True
@@namechars :: '_'

@@keyword :: False      await      else       import     pass
@@keyword :: None       break      except     in         raise
@@keyword :: True       class      finally    is         return
@@keyword :: and        continue   for        lambda     try
@@keyword :: as         def        from       nonlocal   while
@@keyword :: assert     del        global     not        with
@@keyword :: async      elif       if         or         yield


start
    =
    (
      file_input
    | eval_input
    | single_input
    ) $
    ;


single_input
    =
    compound_stmt nl | simple_stmt | nl
    ;


file_input
    =
    {_ string _}*
    {_ import_stmt ~ _}*
    {_ stmt _}* _ ENDMARKER
    ;


eval_input
    =
    testlist _ ENDMARKER
    ;


decorator
    =
    '@' dotted_name ['(' [arglist] ')'] nl
    ;


decorators
    =
    {decorator}+
    ;


decorated
    =
    decorators (classdef | funcdef | async_funcdef)
    ;


async_funcdef
    =
    'async' funcdef
    ;


funcdef
    =
    'def' ~ name parameters ['->' test] ':' [TYPE_COMMENT] func_body_suite
    ;


parameters
    =
    '(' [typedargslist] ')'
    ;


typedargslist
    =
    (| tfpdef ['=' test] {',' [TYPE_COMMENT] tfpdef ['=' test]}* (| TYPE_COMMENT
    | [',' [TYPE_COMMENT] [| '*' [tfpdef] {',' [TYPE_COMMENT] tfpdef ['=' test]}* (TYPE_COMMENT | [',' [TYPE_COMMENT] ['**' tfpdef [','] [TYPE_COMMENT]]])
    | '**' tfpdef [','] [TYPE_COMMENT]]])
    | '*' [tfpdef] {',' [TYPE_COMMENT] tfpdef ['=' test]}* (TYPE_COMMENT | [',' [TYPE_COMMENT] ['**' tfpdef [','] [TYPE_COMMENT]]])
    | '**' tfpdef [','] [TYPE_COMMENT])
    ;


tfpdef
    =
    name [':' ~ test]
    ;


varargslist
    =
    (| vfpdef ['=' test] {',' vfpdef ['=' test]}* [',' [| '*' [vfpdef] {',' vfpdef ['=' test]}* [',' ['**' vfpdef [',']]]
    | '**' vfpdef [',']]]
    | '*' [vfpdef] {',' vfpdef ['=' test]}* [',' ['**' vfpdef [',']]]
    | '**' vfpdef [','])
    ;


vfpdef
    =
    name
    ;


stmt
    =
    compound_stmt | simple_stmt
    ;


simple_stmt
    =
    small_stmt {';' ~ small_stmt}* [';'] nl
    ;


small_stmt
    =
    | expr_stmt
    | flow_stmt
    | del_stmt
    | pass_stmt
    | global_stmt
    | nonlocal_stmt
    | assert_stmt
    | import_stmt
    ;


string_stmt
    =
    string
    ;


expr_stmt
    =
    testlist_star_expr
    (
          annassign
        | augassign (yield_expr | testlist)
        | [{'=' (yield_expr | testlist_star_expr)}+ [TYPE_COMMENT]]
    )
    ;


annassign
    =
    ':' test ['=' ~ (yield_expr | testlist)]
    ;


testlist_star_expr
    =
    (test | star_expr) {',' _ (test | star_expr)}* [',' ~]
    ;


augassign
    =
    | '+='
    | '-='
    | '*='
    | '@='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | '>>='
    | '**='
    | '//='
    ;


del_stmt
    =
    'del' ~ exprlist
    ;


pass_stmt
    =
    'pass' ~
    ;


flow_stmt
    =
    break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
    ;


break_stmt
    =
    'break' ~
    ;


continue_stmt
    =
    'continue' ~
    ;


return_stmt
    =
    'return' ~ [testlist_star_expr]
    ;


yield_stmt
    =
    yield_expr ~
    ;


raise_stmt
    =
    'raise' ~ [test ['from' ~ test]]
    ;


import_stmt
    =
    import_name | import_from
    ;


import_name
    =
    'import' ~ dotted_as_names
    ;


import_from
    =
    'from' ~ ({'.' | '...'}* dotted_name | {'.' | '...'}+)
    'import' ~
    (
          '*' ~
        | '(' ~ import_as_names ')'
        | import_as_names
    )
    ;


import_as_name
    =
    name ['as' ~ name]
    ;


dotted_as_name
    =
    dotted_name ['as' ~ name]
    ;


import_as_names
    =
    import_as_name {',' _ ~ import_as_name}* [',' ~]
    ;


dotted_as_names
    =
    dotted_as_name {',' ~ dotted_as_name}*
    ;


dotted_name
    =
    name {'.' ~ name}*
    ;


global_stmt
    =
    'global' ~ name {',' name}*
    ;


nonlocal_stmt
    =
    'nonlocal' ~ name {',' ~ name}*
    ;


assert_stmt
    =
    'assert' test [',' test]
    ;


compound_stmt
    =
    | if_stmt
    | for_stmt
    | while_stmt
    | try_stmt
    | with_stmt
    | funcdef
    | classdef
    | decorated
    | async_stmt
    ;


async_stmt
    =
    'async' ~ (funcdef | with_stmt | for_stmt)
    ;


if_stmt
    =
    'if' ~ namedexpr_test ':' suite
    {EQDENT 'elif' ~ namedexpr_test ':' suite}*
    [EQDENT 'else' ~ ':' suite]
    ;


while_stmt
    =
    'while' ~ namedexpr_test ':' suite ['else' ':' suite]
    ;


for_stmt
    =
    'for' ~ exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite]
    ;


try_stmt
    =
    'try' ~ ':' suite
    (
            {except_clause ~ ':' suite}+ ~
            ['else' ~ ':' suite]
            ['finally' ~ ':' suite]
        |
            'finally' ~ ':' suite
    )
    ;


with_stmt
    =
    'with' ~ with_item {',' with_item}* ':' [TYPE_COMMENT] suite
    ;


with_item
    =
    test ['as' expr]
    ;


except_clause
    =
    'except' ~ [test ['as' name]]
    ;


suite
    =
      nl ~ INDENT stmt ~ {EQDENT stmt ~}* ~ DEDENT
    | simple_stmt
    ;


namedexpr_test
    =
    test [':=' ~ test]
    ;


test
    =
    lambdef | or_test ['if' ~ or_test 'else' ~ test]
    ;


test_nocond
    =
    or_test | lambdef_nocond
    ;


lambdef
    =
    'lambda' ~ [varargslist] ':' _ test
    ;


lambdef_nocond
    =
    'lambda' [varargslist] ':' test_nocond
    ;


or_test
    =
    and_test {_ 'or' ~ _ and_test}*
    ;


and_test
    =
    not_test {_ 'and' ~ _ not_test}*
    ;


not_test
    =
    'not' not_test | comparison
    ;


comparison
    =
    expr {comp_op ~ expr}*
    ;


comp_op
    =
    | '=='
    | '>='
    | '<='
    | '<>'
    | '<'
    | '>'
    | '!='
    | 'not' 'in'
    | 'in'
    | 'is' 'not'
    | 'is'
    ;


star_expr
    =
    '*' ~ expr
    ;


expr
    =
    xor_expr {'|' ~ xor_expr}*
    ;


xor_expr
    =
    and_expr {'^' ~ and_expr}*
    ;


and_expr
    =
    shift_expr {'&' ~ shift_expr}*
    ;


shift_expr
    =
    arith_expr {('<<' | '>>') ~ arith_expr}*
    ;


arith_expr
    =
    term {_ ('+' | '-') !'=' ~ _ term}*
    ;


term
    =
    factor {_ ('*' !'*' | '@' | '%' | '//' | '/') !'=' ~ _ factor}*
    ;


factor
    =
    ('+' | '-' | '~') ~ factor | power
    ;


power
    =
    atom_expr ['**' ~ factor]
    ;


atom_expr
    =
    ['await' ~] atom {trailer}*
    ;


atom
    =
    ( '(' _ [yield_expr | testlist_comp] _ ')'
    | '[' _ [testlist_comp] _ ']'
    | '{' _ [dictorsetmaker] _ '}'
    | string
    | number
    | '...'
    | 'None'
    | 'True'
    | 'False')
    | name
    ;


testlist_comp
    =
    (namedexpr_test | star_expr) _
    (
          comp_for
        | {',' _ (namedexpr_test | star_expr) ~ _}* [',']
    )
    ;


trailer
    =
    '(' ~ [arglist] ')' | '[' ~ subscriptlist ']' | '.' ~ name
    ;


subscriptlist
    =
    subscript {','  _ subscript _ }* [',']
    ;


subscript
    =
    [test] ':' ~ [test] [sliceop] | test
    ;


sliceop
    =
    ':' ~ [test]
    ;


exprlist
    =
    (expr | star_expr) {',' (expr | star_expr)}* [',']
    ;


testlist
    =
    test {',' test}* [',']
    ;


dictorsetmaker
    =
        (test ':' test | '**' expr) _
        (comp_for | {',' _ (test ':' test | '**' expr) ~}* [','])
    |
        (test | star_expr) _
        (comp_for | {','  _ (test | star_expr) ~ }* [','])
    ;


classdef
    =
    'class' ~ name ['(' [arglist] ')'] ':' suite
    ;


arglist
    =
    _ argument {',' _ argument}* [',' ~ _]
    ;


argument
    =
    | test ':=' test
    | test '=' test
    | '**' test
    | '*' test
    | test [comp_for]
    ;


comp_iter
    =
    comp_for | comp_if
    ;


sync_comp_for
    =
    'for' ~ exprlist 'in' ~ or_test [_ comp_iter]
    ;


comp_for
    =
    ['async' ~] sync_comp_for
    ;


comp_if
    =
    'if' ~ test_nocond [_ comp_iter]
    ;


encoding_decl
    =
    name
    ;


yield_expr
    =
    'yield' ~ [yield_arg]
    ;


yield_arg
    =
    'from' ~ test | testlist_star_expr
    ;


func_body_suite
    =
      nl ~ [TYPE_COMMENT ~ nl] INDENT stmt ~ {EQDENT stmt ~}* DEDENT
    | simple_stmt
    ;


func_type_input
    =
    func_type [nl] ENDMARKER
    ;


func_type
    =
    '(' [typelist] ')' '->' ~ test
    ;


typelist
    =
        | '**' ~ test
        | test {',' ~ test}* ['**' ~ test]
        | '*' [test] {',' ~ test}* [',' '**' ~ test]
        | ',' ['*' ~ [test] {',' test}* [',' '**' ~ test]]
    ;


@name
name
    =
    /[_]*\w[\w_]*/
    ;


number
    =
    floatnumber
    | integer
    ;


integer
    =
    bininteger | octinteger | hexinteger | decinteger
    ;


decinteger
    =
    #  nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
    /[1-9]([_]?\d)*|0+([_]?0)*/
    ;


bininteger
    =
    # "0" ("b" | "B") (["_"] bindigit)+
    /0[bB]([_]?[01])+/
    ;


octinteger
    =
    # "0" ("o" | "O") (["_"] octdigit)+
    /0[oO]([_]?[0-7])+/
    ;


hexinteger
    =
    # "0" ("x" | "X") (["_"] hexdigit)+
    /0[xX]([_]?[\da-fA-F])+/
    ;


floatnumber
    =
    # floatnumber   ::=  pointfloat | exponentfloat
    # pointfloat    ::=  [digitpart] fraction | digitpart "."
    # exponentfloat ::=  (digitpart | pointfloat) exponent
    # digitpart     ::=  digit (["_"] digit)*
    # fraction      ::=  "." digitpart
    # exponent      ::=  ("e" | "E") ["+" | "-"] digitpart
    | /[.]\d+([eE][-+]?\d([_]?\d)*)?/
    | /\d([_]?\d)*[.]\d*([eE][-+]?\d([_]?\d)*)?/
    | /\d([_]?\d)*[eE][-+]?\d([_]?\d)*/
    ;


string
    =
    (f_string|n_string) ~ {_ (f_string|n_string)}*
    ;

n_string
    =
    STRING
    ;

STRING
    =
    &/(r[bu]?|[bu]r?)?('''|""")/ ~
    /(?xs)
    (r[bu]?|[bu]r?)?'''(.|\\|\'|\.)*?'''
    |
    (r[bu]?|[bu]r?)?"""(.|\\|\"|\.)*?"""
    /
    |
    &/(r[bu]?|[bu]r?)?["']/ ~
    /(?xs)
    (r[bu]?|[bu]r?)?'(.|\\|\'|\.)*?'
    |
    (r[bu]?|[bu]r?)?"(.|\\|\"|\.)*?"
    /
    ;


f_string
    =
    FSTRING
    ;

FSTRING
    =
    &/f(r[bu]?|[bu]r?)?('''|""")/ ~
    /(?xs)
    f(r[bu]?|[bu]r?)?'''(.|\\|\'|\.)*?'''
    |
    f(r[bu]?|[bu]r?)?"""(.|\\|\"|\.)*?"""
    /
    |
    &/f(r[bu]?|[bu]r?)?["']/ ~
    /(?xs)
    f(r[bu]?|[bu]r?)?'(.|\\|\'|\.)*?'
    |
    f(r[bu]?|[bu]r?)?"(.|\\|\"|\.)*?"
    /
    ;


nl = /(?:(?:\s|\\\n)*(?:#[^\n]*?)?\n)+/ ~ | /\s*$/ $;

_ = /(?:(?:\s|\\\n)*(?:#[^\n]*?)?\n)*/ ;

@nomemo
INDENT = /(?:\s*(?:#[^\n]*?)?\n)*/  @:/^\s+/ ;

@nomemo
DEDENT = /(?:\s*(?:#[^\n]*?)?\n)*/  @:&/^\s*/ ;

@nomemo
EQDENT = /(?:\s*(?:#.[^\n]*?)?\n)*/  @:&/^\s*/ ;

ENDMARKER = $ ;

TYPE_COMMENT
    =
    /\s*#\s*type:.*$/
    ;

